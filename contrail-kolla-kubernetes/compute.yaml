heat_template_version: '2017-02-24'
parameters:
  stackname:
    type: string
  name:
    type: string
  flavor:
    type: string
  image:
    type: string
  availability_zone:
    type: string
  public_net:
    type: string
  key_name:
    type: string
  firstnet:
    type: string
  firstnet_ip:
    type: string
  secondnet:
    type: string
  secondnet_ip:
    type: string
  networks:
    type: json
  public_key:
    type: string
  private_key:
    type: string
  compute_count:
    type: string
  
outputs:
  floating_ip_address:
    value:
      get_attr: [floating_ip, floating_ip_address]
resources:
  server:
    type: OS::Nova::Server
    properties:
      availability_zone: { get_param: availability_zone}
      flavor: { get_param: flavor}
      image: { get_param: image}
      key_name: {get_param: key_name}
      name: 
        str_replace:
          template: stacknamename
          params:
            stackname: { get_param: stackname }
            name: { get_param: name }
      networks: 
      - port: { get_resource: firstnet_port }
      - port: { get_resource: secondnet_port }
      user_data: {get_resource: cloud_config}
      user_data_format: RAW
  firstnet_port:
    properties:
      network: {get_param: firstnet}
      fixed_ips: [ {  "ip_address": { get_param: firstnet_ip } } ]
      security_groups: 
      - { get_resource: security_group}      
    type: OS::Neutron::Port
  secondnet_port:
    properties:
      network: {get_param: secondnet}
      fixed_ips: [ {  "ip_address": { get_param: secondnet_ip } } ]
    type: OS::Neutron::Port
  floating_ip:
    properties: {floating_network: { get_param: public_net }}
    type: OS::Neutron::FloatingIP
  floating_ip_asociate:
    properties:
      floatingip_id: {get_resource: floating_ip}
      port_id: { get_resource: firstnet_port }
    type: OS::Neutron::FloatingIPAssociation
  security_group_random:
    type: OS::Heat::RandomString
  security_group:
    properties:
      name:
        get_attr: [security_group_random, value]
      rules:
      - {port_range_max: 65535, port_range_min: 0, protocol: tcp, remote_ip_prefix: 0.0.0.0/0}
      - {port_range_max: 65535, port_range_min: 0, protocol: udp, remote_ip_prefix: 0.0.0.0/0}
      - {protocol: icmp, remote_ip_prefix: 0.0.0.0/0}
    type: OS::Neutron::SecurityGroup
  cloud_config:
    properties:
      parts:
      - config: { get_resource: common_config }
    type: OS::Heat::MultipartMime
  common_config:
    properties:
      cloud_config:
        disable_root: 0
        package_upgrade: true
        runcmd:
        - str_replace:
            params:
              stackname: { get_param: stackname }
              servercount: { get_param: compute_count }
              control_hostname:   { get_param: [ networks, first_network , hosts, control, name]}
              contrail_hostname:  { get_param: [ networks, first_network , hosts, contrail, name]}
              compute_hostname:  { get_param: [ networks, first_network , hosts, compute, name]}
              contrail_device: { get_param: [ networks, first_network , device]}
              control_ip:  { get_param: [ networks, first_network , hosts, control, ip]}
              contrail_ip: { get_param: [ networks, first_network , hosts, contrail, ip]}
              compute_ip: { get_param: [ networks, first_network , hosts, compute, ipprefix]}
              docker_bridge_ip: { get_param: [ networks, docker_bridge ]}
              external_device: { get_param: [ networks, second_network, device]}
              wc_notify: { get_attr: ['wait_handle', 'curl_cli'] }
            template: |
              
              set -x
              echo "control_ip  stacknamecontrol_hostname" >> /etc/hosts
              echo "contrail_ip stacknamecontrail_hostname" >> /etc/hosts
              ssh-keyscan localhost >> /root/.ssh/known_hosts
              ssh-keyscan stacknamecontrol_hostname >> /root/.ssh/known_hosts
              ssh-keyscan stacknamecontrail_hostname >> /root/.ssh/known_hosts
              ssh-keyscan 127.0.0.1 >> /root/.ssh/known_hosts
              ssh-keyscan control_ip >> /root/.ssh/known_hosts
              ssh-keyscan contrail_ip >> /root/.ssh/known_hosts
              i=0
              computehosts_list=''
              computeip_list=''
              while true
              do
                 if [ $i -ge servercount ]
                 then
                   break
                 fi
                 echo "compute_ip$i stacknamecompute_hostname$i" >> /etc/hosts
                 ssh-keyscan stacknamecompute_hostname$i >> /root/.ssh/known_hosts
                 ssh-keyscan compute_ip$i >> /root/.ssh/known_hosts
                 computehosts_list="${computehosts_list}stacknamecompute_hostname$i\n"
                 computeip_list="${computeip_list}compute_ip$i\n"
                 i=$((i+1))
              done
              apt-get install -y python docker docker.io
              python -c 'import json; obj={}; obj["bip"]="docker_bridge_ip"; print(json.dumps(obj))' > /etc/docker/daemon.json
              systemctl restart docker
              apt-get install --no-install-recommends -y git
              git clone https://git.openstack.org/openstack/openstack-helm-infra.git /opt/openstack-helm-infra
              git clone https://git.openstack.org/openstack/openstack-helm.git /opt/openstack-helm
              
                
              if [ `hostname` = "stacknamecontrol_hostname" ]
              then
                apt-get install --no-install-recommends -y ca-certificates git make jq nmap curl uuid-runtime ipcalc
              cat > /opt/openstack-helm-infra/tools/gate/devel/multinode-inventory.yaml <<EOF
              all:
                children:
                  primary:
                    hosts:
                      stacknamecontrol_hostname:
                        ansible_port: 22
                        ansible_host: $control_ip
                        ansible_user: root
                  nodes:
                    hosts:
              EOF
                i=0
                while true
                do
                  if [ $i -ge servercount ]
                  then 
                   break
                  fi
              cat >> /opt/openstack-helm-infra/tools/gate/devel/multinode-inventory.yaml <<EOF
                      stacknamecompute_hostname$i:
                        ansible_port: 22
                        ansible_host: compute_ip$i
                        ansible_user: root
              EOF
                  i=$((i+1))
                done
              cat > /opt/openstack-helm-infra/tools/gate/devel/multinode-vars.yaml <<EOF
              kubernetes:
                network:
                  default_device: contrail_device
                cluster:
                  cni: calico
                  pod_subnet: 172.16.0.0/16
                  domain: cluster.local
              EOF
                ( cd /opt/openstack-helm-infra ; make dev-deploy setup-host multinode )
                ( cd /opt/openstack-helm-infra ; make dev-deploy k8s multinode )

                #( cd /opt/openstack-helm ; ./tools/deployment/multinode/010-setup-client.sh )
                #( cd /opt/openstack-helm ; ./tools/deployment/multinode/020-ingress.sh )
                #( cd /opt/openstack-helm ; ./tools/deployment/multinode/050-mariadb.sh )
                #( cd /opt/openstack-helm ; ./tools/deployment/multinode/060-rabbitmq.sh )
                #( cd /opt/openstack-helm ; ./tools/deployment/multinode/070-memcached.sh )
                #( cd /opt/openstack-helm ; ./tools/deployment/multinode/080-keystone.sh )
                #( cd /opt/openstack-helm ; ./tools/deployment/multinode/100-glance.sh )
                #( cd /opt/openstack-helm ; ./tools/deployment/multinode/130-libvirt.sh )
                #( cd /opt/openstack-helm ; ./tools/deployment/multinode/150-heat.sh )
`
              fi    
              wc_notify --data-binary '{"status": "SUCCESS"}'
        write_files:
        - path: /root/.ssh/id_rsa
          permissions: 0600
          content:
            get_param: private_key
        - path: /root/.ssh/authorized_keys
          permissions: 0600
          content:
            get_param: public_key
    type: OS::Heat::CloudConfig
  wait_condition:
    type: OS::Heat::WaitCondition
    properties:
      handle: {get_resource: wait_handle}
      timeout: 3600
  wait_handle:
    type: OS::Heat::WaitConditionHandle

